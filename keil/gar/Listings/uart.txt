; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\Device\Nuvoton\Nano100Series\Include -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -IC:\Users\rui\AppData\Local\Arm\Packs\Nuvoton\NuMicro_DFP\1.3.19\Device\NANO100BN\Include -IC:\Keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=538 --omf_browse=.\objects\uart.crf ..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearIntFlag PROC
;;;40      */
;;;41     void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag)
000000  074a              LSLS     r2,r1,#29
;;;42     {
000002  d507              BPL      |L1.20|
;;;43     
;;;44         if(u32InterruptFlag & UART_ISR_RLS_IS_Msk)   /* clear Receive Line Status Interrupt */
;;;45         {
;;;46             uart->FSR |= UART_FSR_BI_F_Msk | UART_FSR_FE_F_Msk | UART_FSR_PE_F_Msk;
000004  6982              LDR      r2,[r0,#0x18]
000006  2370              MOVS     r3,#0x70
000008  431a              ORRS     r2,r2,r3
00000a  6182              STR      r2,[r0,#0x18]
;;;47             uart->TRSR |= UART_TRSR_RS485_ADDET_F_Msk;
00000c  6942              LDR      r2,[r0,#0x14]
00000e  2301              MOVS     r3,#1
000010  431a              ORRS     r2,r2,r3
000012  6142              STR      r2,[r0,#0x14]
                  |L1.20|
;;;48         }
;;;49     
;;;50         if(u32InterruptFlag & UART_ISR_MODEM_IS_Msk)  /* clear Modem Interrupt */
000014  070a              LSLS     r2,r1,#28
000016  d504              BPL      |L1.34|
;;;51             uart->MCSR |= UART_MCSR_DCT_F_Msk;
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  2301              MOVS     r3,#1
00001c  049b              LSLS     r3,r3,#18
00001e  431a              ORRS     r2,r2,r3
000020  61c2              STR      r2,[r0,#0x1c]
                  |L1.34|
;;;52     
;;;53         if(u32InterruptFlag & UART_ISR_BUF_ERR_IS_Msk)   /* clear Buffer Error Interrupt */
000022  068a              LSLS     r2,r1,#26
000024  d504              BPL      |L1.48|
;;;54         {
;;;55             uart->FSR |= UART_FSR_RX_OVER_F_Msk | UART_FSR_TX_OVER_F_Msk;
000026  6982              LDR      r2,[r0,#0x18]
000028  23ff              MOVS     r3,#0xff
00002a  3302              ADDS     r3,#2
00002c  431a              ORRS     r2,r2,r3
00002e  6182              STR      r2,[r0,#0x18]
                  |L1.48|
;;;56         }
;;;57     
;;;58         if(u32InterruptFlag & UART_ISR_WAKE_IS_Msk)   /* clear wake up Interrupt */
000030  064a              LSLS     r2,r1,#25
000032  d503              BPL      |L1.60|
;;;59         {
;;;60             uart->ISR |= UART_ISR_WAKE_IS_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  2340              MOVS     r3,#0x40
000038  431a              ORRS     r2,r2,r3
00003a  6102              STR      r2,[r0,#0x10]
                  |L1.60|
;;;61         }
;;;62     
;;;63         if(u32InterruptFlag & UART_ISR_ABAUD_IS_Msk)   /* clear auto-baud rate Interrupt */
00003c  060a              LSLS     r2,r1,#24
00003e  d503              BPL      |L1.72|
;;;64         {
;;;65             uart->TRSR |= UART_TRSR_ABAUD_TOUT_F_Msk | UART_TRSR_ABAUD_F_Msk;
000040  6942              LDR      r2,[r0,#0x14]
000042  2306              MOVS     r3,#6
000044  431a              ORRS     r2,r2,r3
000046  6142              STR      r2,[r0,#0x14]
                  |L1.72|
;;;66         }
;;;67     
;;;68         if(u32InterruptFlag & UART_ISR_LIN_IS_Msk)   /* clear LIN break Interrupt */
000048  05c9              LSLS     r1,r1,#23
00004a  d503              BPL      |L1.84|
;;;69         {
;;;70             uart->TRSR |= UART_TRSR_LIN_TX_F_Msk | UART_TRSR_LIN_RX_F_Msk | UART_TRSR_BIT_ERR_F_Msk;
00004c  6941              LDR      r1,[r0,#0x14]
00004e  2238              MOVS     r2,#0x38
000050  4311              ORRS     r1,r1,r2
000052  6141              STR      r1,[r0,#0x14]
                  |L1.84|
;;;71         }
;;;72     
;;;73     }
000054  4770              BX       lr
;;;74     
                          ENDP


                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;82      */
;;;83     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;84     {
;;;85         uart->IER = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;86     }
000004  4770              BX       lr
;;;87     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;95      */
;;;96     void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;97     {
;;;98         uart->CTL &= ~(UART_CTL_AUTO_RTS_EN_Msk | UART_CTL_AUTO_CTS_EN_Msk);
000002  2230              MOVS     r2,#0x30
000004  4391              BICS     r1,r1,r2
000006  6041              STR      r1,[r0,#4]
;;;99     }
000008  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;119     */
;;;120    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  68c2              LDR      r2,[r0,#0xc]
;;;121    {
;;;122        uart->IER &= ~ u32InterruptFlag;
000002  438a              BICS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;123    }
000006  4770              BX       lr
;;;124    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=2

                  UART_EnableFlowCtrl PROC
;;;133     */
;;;134    void UART_EnableFlowCtrl(UART_T* uart )
000000  69c1              LDR      r1,[r0,#0x1c]
;;;135    {
;;;136        uart->MCSR |= UART_MCSR_LEV_RTS_Msk | UART_MCSR_LEV_CTS_Msk;
000002  4a04              LDR      r2,|L5.20|
000004  4311              ORRS     r1,r1,r2
000006  61c1              STR      r1,[r0,#0x1c]
;;;137        uart->CTL |= UART_CTL_AUTO_RTS_EN_Msk | UART_CTL_AUTO_CTS_EN_Msk;
000008  6841              LDR      r1,[r0,#4]
00000a  2230              MOVS     r2,#0x30
00000c  4311              ORRS     r1,r1,r2
00000e  6041              STR      r1,[r0,#4]
;;;138    }
000010  4770              BX       lr
;;;139    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x00010001

                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;158     */
;;;159    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  68c2              LDR      r2,[r0,#0xc]
;;;160    {
;;;161        uart->IER |= u32InterruptFlag;
000002  430a              ORRS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;162    }
000006  4770              BX       lr
;;;163    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;172     */
;;;173    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b57f              PUSH     {r0-r6,lr}
;;;174    {
;;;175        uint8_t u8UartClkSrcSel;
;;;176        uint32_t u32ClkTbl[4] = {__HXT, __LXT, 0, __HIRC12M};
000002  4a19              LDR      r2,|L7.104|
000004  460e              MOV      r6,r1                 ;174
000006  4604              MOV      r4,r0                 ;174
000008  ca0f              LDM      r2,{r0-r3}
00000a  466d              MOV      r5,sp
00000c  c50f              STM      r5!,{r0-r3}
;;;177        uint32_t u32Baud_Div;
;;;178        uint32_t u32SrcFreq;
;;;179        uint32_t u32SrcFreqDiv;
;;;180    
;;;181        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
00000e  4917              LDR      r1,|L7.108|
000010  6948              LDR      r0,[r1,#0x14]
;;;182    
;;;183        u32SrcFreq = u32ClkTbl[u8UartClkSrcSel];
000012  466a              MOV      r2,sp
000014  0780              LSLS     r0,r0,#30             ;181
000016  0f00              LSRS     r0,r0,#28
000018  5810              LDR      r0,[r2,r0]
;;;184    
;;;185        u32SrcFreqDiv = (((CLK->CLKDIV0 & CLK_CLKDIV0_UART_N_Msk) >> CLK_CLKDIV0_UART_N_Pos) + 1);
00001a  69c9              LDR      r1,[r1,#0x1c]
;;;186    
;;;187        if(u32SrcFreq == 0)
;;;188        {
;;;189            u32SrcFreq = SysGet_PLLClockFreq() / u32SrcFreqDiv;
;;;190        }
;;;191        else
;;;192        {
;;;193            u32SrcFreq = u32SrcFreq / u32SrcFreqDiv;
;;;194        }
;;;195    
;;;196        uart->FUN_SEL = UART_FUNC_SEL_UART;
;;;197        uart->TLCTL = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1 |
;;;198                      UART_TLCTL_RFITL_1BYTE | UART_TLCTL_RTS_TRI_LEV_1BYTE;
;;;199    
;;;200        if(u32baudrate != 0)
;;;201        {
;;;202            u32Baud_Div = UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32baudrate);
;;;203    
;;;204            if(u32Baud_Div > 0xFFFF)
;;;205                uart->BAUD = (UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32baudrate));
;;;206            else
;;;207                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;208        }
;;;209    }
00001c  0509              LSLS     r1,r1,#20
00001e  0f0d              LSRS     r5,r1,#28
000020  1c6d              ADDS     r5,r5,#1
000022  2800              CMP      r0,#0                 ;187
000024  d101              BNE      |L7.42|
000026  f7fffffe          BL       SysGet_PLLClockFreq
                  |L7.42|
00002a  4629              MOV      r1,r5                 ;193
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  4605              MOV      r5,r0                 ;193
000032  2000              MOVS     r0,#0                 ;196
000034  63a0              STR      r0,[r4,#0x38]         ;196
000036  2003              MOVS     r0,#3                 ;197
000038  60a0              STR      r0,[r4,#8]            ;197
00003a  2e00              CMP      r6,#0                 ;200
00003c  d013              BEQ      |L7.102|
00003e  0870              LSRS     r0,r6,#1              ;202
000040  1940              ADDS     r0,r0,r5              ;202
000042  4631              MOV      r1,r6                 ;202
000044  f7fffffe          BL       __aeabi_uidivmod
000048  4909              LDR      r1,|L7.112|
00004a  1e40              SUBS     r0,r0,#1              ;204
00004c  4288              CMP      r0,r1                 ;204
00004e  d909              BLS      |L7.100|
000050  00f0              LSLS     r0,r6,#3              ;205
000052  1940              ADDS     r0,r0,r5              ;205
000054  4631              MOV      r1,r6                 ;205
000056  f7fffffe          BL       __aeabi_uidivmod
00005a  2101              MOVS     r1,#1                 ;205
00005c  0900              LSRS     r0,r0,#4              ;205
00005e  07c9              LSLS     r1,r1,#31             ;205
000060  1e40              SUBS     r0,r0,#1              ;205
000062  4308              ORRS     r0,r0,r1              ;205
                  |L7.100|
000064  6260              STR      r0,[r4,#0x24]         ;207
                  |L7.102|
000066  bd7f              POP      {r0-r6,pc}
;;;210    
                          ENDP

                  |L7.104|
                          DCD      ||.constdata||
                  |L7.108|
                          DCD      0x50000200
                  |L7.112|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;221     */
;;;222    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
000002  4604              MOV      r4,r0
;;;224        uint32_t  u32Count, u32delayno;
;;;225    
;;;226        for(u32Count=0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;227        {
;;;228            u32delayno = 0;
;;;229    
;;;230            while(uart->FSR & UART_FSR_RX_EMPTY_F_Msk)   /* Check RX empty => failed */
;;;231            {
;;;232                u32delayno++;
;;;233                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L8.38|
                  |L8.12|
00000c  2300              MOVS     r3,#0                 ;228
00000e  e004              B        |L8.26|
                  |L8.16|
000010  1c5b              ADDS     r3,r3,#1              ;230
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L8.26|
;;;234                    return FALSE;
000016  2000              MOVS     r0,#0
;;;235            }
;;;236            pu8RxBuf[u32Count] = uart->RBR;    /* Get Data from UART RX  */
;;;237        }
;;;238    
;;;239        return u32Count;
;;;240    
;;;241    }
000018  bd70              POP      {r4-r6,pc}
                  |L8.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;230
00001c  07b6              LSLS     r6,r6,#30             ;230
00001e  d4f7              BMI      |L8.16|
000020  6823              LDR      r3,[r4,#0]            ;236
000022  540b              STRB     r3,[r1,r0]            ;236
000024  1c40              ADDS     r0,r0,#1              ;236
                  |L8.38|
000026  4290              CMP      r0,r2                 ;226
000028  d3f0              BCC      |L8.12|
00002a  bd70              POP      {r4-r6,pc}
;;;242    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;316     */
;;;317    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f0              PUSH     {r4-r7,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319        uint8_t u8UartClkSrcSel;
;;;320        uint32_t u32ClkTbl[4] = {__HXT, __LXT, 0, __HIRC12M};
000004  481a              LDR      r0,|L9.112|
000006  4615              MOV      r5,r2                 ;318
000008  460e              MOV      r6,r1                 ;318
00000a  c80f              LDM      r0,{r0-r3}
00000c  b085              SUB      sp,sp,#0x14           ;318
00000e  466f              MOV      r7,sp
000010  c70f              STM      r7!,{r0-r3}
;;;321        uint32_t u32SrcFreq;
;;;322        uint32_t u32SrcFreqDiv;
;;;323    
;;;324        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000012  4918              LDR      r1,|L9.116|
000014  6948              LDR      r0,[r1,#0x14]
;;;325    
;;;326        u32SrcFreq = u32ClkTbl[u8UartClkSrcSel];
000016  466a              MOV      r2,sp
000018  0780              LSLS     r0,r0,#30             ;324
00001a  0f00              LSRS     r0,r0,#28
00001c  5810              LDR      r0,[r2,r0]
;;;327    
;;;328        u32SrcFreqDiv = (((CLK->CLKDIV0 & CLK_CLKDIV0_UART_N_Msk) >> CLK_CLKDIV0_UART_N_Pos) + 1);
00001e  69c9              LDR      r1,[r1,#0x1c]
;;;329    
;;;330        if(u32SrcFreq == 0)
;;;331        {
;;;332            u32SrcFreq = SysGet_PLLClockFreq() / u32SrcFreqDiv;
;;;333        }
;;;334        else
;;;335        {
;;;336            u32SrcFreq = u32SrcFreq / u32SrcFreqDiv;
;;;337        }
;;;338    
;;;339        uart->BAUD = UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32Buadrate);
;;;340    
;;;341        uart->IRCR    &=  ~UART_IRCR_INV_TX_Msk;
;;;342        uart->IRCR |=     UART_IRCR_INV_RX_Msk;
;;;343        uart->IRCR    = u32Direction ? uart->IRCR | UART_IRCR_TX_SELECT_Msk : uart->IRCR &~ UART_IRCR_TX_SELECT_Msk;
;;;344        uart->FUN_SEL = (0x2 << UART_FUN_SEL_FUN_SEL_Pos);
;;;345    }
000020  0509              LSLS     r1,r1,#20
000022  0f0f              LSRS     r7,r1,#28
000024  1c7f              ADDS     r7,r7,#1
000026  2800              CMP      r0,#0                 ;330
000028  d101              BNE      |L9.46|
00002a  f7fffffe          BL       SysGet_PLLClockFreq
                  |L9.46|
00002e  4639              MOV      r1,r7                 ;336
000030  f7fffffe          BL       __aeabi_uidivmod
000034  00f1              LSLS     r1,r6,#3              ;339
000036  1808              ADDS     r0,r1,r0              ;339
000038  4631              MOV      r1,r6                 ;339
00003a  f7fffffe          BL       __aeabi_uidivmod
00003e  2101              MOVS     r1,#1                 ;339
000040  0900              LSRS     r0,r0,#4              ;339
000042  07c9              LSLS     r1,r1,#31             ;339
000044  1e40              SUBS     r0,r0,#1              ;339
000046  4308              ORRS     r0,r0,r1              ;339
000048  6260              STR      r0,[r4,#0x24]         ;339
00004a  6b20              LDR      r0,[r4,#0x30]         ;341
00004c  2120              MOVS     r1,#0x20              ;341
00004e  4388              BICS     r0,r0,r1              ;341
000050  6320              STR      r0,[r4,#0x30]         ;341
000052  6b20              LDR      r0,[r4,#0x30]         ;342
000054  2140              MOVS     r1,#0x40              ;342
000056  4308              ORRS     r0,r0,r1              ;342
000058  6320              STR      r0,[r4,#0x30]         ;342
00005a  2102              MOVS     r1,#2                 ;343
00005c  6b20              LDR      r0,[r4,#0x30]         ;343
00005e  2d00              CMP      r5,#0                 ;343
000060  d001              BEQ      |L9.102|
000062  4308              ORRS     r0,r0,r1              ;343
000064  e000              B        |L9.104|
                  |L9.102|
000066  4388              BICS     r0,r0,r1              ;343
                  |L9.104|
000068  6320              STR      r0,[r4,#0x30]         ;343
00006a  63a1              STR      r1,[r4,#0x38]         ;344
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
;;;346    
                          ENDP

                  |L9.112|
                          DCD      ||.constdata||+0x20
                  |L9.116|
                          DCD      0x50000200

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;377     */
;;;378    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;379    {
;;;380        /* Select LIN function mode */
;;;381        uart->FUN_SEL = UART_FUNC_SEL_LIN;
000002  2301              MOVS     r3,#1
000004  6383              STR      r3,[r0,#0x38]
;;;382    
;;;383        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;384        uart->FUN_SEL = UART_FUNC_SEL_LIN;
000006  6383              STR      r3,[r0,#0x38]
;;;385        uart->ALT_CTL &= ~(UART_ALT_CTL_LIN_TX_BCNT_Msk | UART_ALT_CTL_LIN_RX_EN_Msk | UART_ALT_CTL_LIN_TX_EN_Msk);
000008  6b43              LDR      r3,[r0,#0x34]
00000a  24c7              MOVS     r4,#0xc7
00000c  43a3              BICS     r3,r3,r4
00000e  6343              STR      r3,[r0,#0x34]
;;;386        uart->ALT_CTL |= u32BreakLength & UART_ALT_CTL_LIN_TX_BCNT_Msk;
000010  6b43              LDR      r3,[r0,#0x34]
000012  0752              LSLS     r2,r2,#29
000014  0f52              LSRS     r2,r2,#29
000016  4313              ORRS     r3,r3,r2
000018  6343              STR      r3,[r0,#0x34]
;;;387        uart->ALT_CTL |= u32Mode;
00001a  6b42              LDR      r2,[r0,#0x34]
00001c  430a              ORRS     r2,r2,r1
00001e  6342              STR      r2,[r0,#0x34]
;;;388    }
000020  bd10              POP      {r4,pc}
;;;389    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=1

                  UART_SelectRS485Mode PROC
;;;356     */
;;;357    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  2303              MOVS     r3,#3
;;;358    {
;;;359        uart->FUN_SEL = UART_FUNC_SEL_RS485;
000002  6383              STR      r3,[r0,#0x38]
;;;360        uart->ALT_CTL = 0;
000004  2300              MOVS     r3,#0
000006  6343              STR      r3,[r0,#0x34]
;;;361        uart->ALT_CTL |= u32Mode | (u32Addr << UART_ALT_CTL_ADDR_PID_MATCH_Pos);
000008  6b43              LDR      r3,[r0,#0x34]
00000a  0612              LSLS     r2,r2,#24
00000c  430a              ORRS     r2,r2,r1
00000e  4313              ORRS     r3,r3,r2
000010  6343              STR      r3,[r0,#0x34]
;;;362    }
000012  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;255     */
;;;256    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;257    {
;;;258        uint8_t u8UartClkSrcSel;
;;;259        uint32_t u32ClkTbl[4] = {__HXT, __LXT, 0, __HIRC12M};
000002  4b1b              LDR      r3,|L12.112|
000004  4616              MOV      r6,r2                 ;257
000006  460c              MOV      r4,r1                 ;257
000008  4605              MOV      r5,r0                 ;257
00000a  cb0f              LDM      r3,{r0-r3}
00000c  b085              SUB      sp,sp,#0x14           ;257
00000e  466f              MOV      r7,sp
000010  c70f              STM      r7!,{r0-r3}
;;;260        uint32_t u32Baud_Div = 0;
;;;261        uint32_t u32SrcFreq;
;;;262        uint32_t u32SrcFreqDiv;
;;;263    
;;;264        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000012  4918              LDR      r1,|L12.116|
000014  6948              LDR      r0,[r1,#0x14]
;;;265    
;;;266        u32SrcFreq = u32ClkTbl[u8UartClkSrcSel];
000016  466a              MOV      r2,sp
000018  0780              LSLS     r0,r0,#30             ;264
00001a  0f00              LSRS     r0,r0,#28
00001c  5810              LDR      r0,[r2,r0]
;;;267    
;;;268        u32SrcFreqDiv = (((CLK->CLKDIV0 & CLK_CLKDIV0_UART_N_Msk) >> CLK_CLKDIV0_UART_N_Pos) + 1);
00001e  69c9              LDR      r1,[r1,#0x1c]
;;;269    
;;;270        if(u32SrcFreq == 0)
;;;271        {
;;;272            u32SrcFreq = SysGet_PLLClockFreq() / u32SrcFreqDiv;
;;;273        }
;;;274        else
;;;275        {
;;;276            u32SrcFreq = u32SrcFreq / u32SrcFreqDiv;
;;;277        }
;;;278    
;;;279        if(u32baudrate != 0)
;;;280        {
;;;281            u32Baud_Div = UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32baudrate);
;;;282    
;;;283            if(u32Baud_Div > 0xFFFF)
;;;284                uart->BAUD = (UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32baudrate));
;;;285            else
;;;286                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;287        }
;;;288    
;;;289        uart->TLCTL = u32data_width | u32parity | u32stop_bits;
;;;290    }
000020  0509              LSLS     r1,r1,#20
000022  0f0f              LSRS     r7,r1,#28
000024  1c7f              ADDS     r7,r7,#1
000026  2800              CMP      r0,#0                 ;270
000028  d101              BNE      |L12.46|
00002a  f7fffffe          BL       SysGet_PLLClockFreq
                  |L12.46|
00002e  4639              MOV      r1,r7                 ;276
000030  f7fffffe          BL       __aeabi_uidivmod
000034  4607              MOV      r7,r0                 ;276
000036  2c00              CMP      r4,#0                 ;279
000038  d013              BEQ      |L12.98|
00003a  0860              LSRS     r0,r4,#1              ;281
00003c  19c0              ADDS     r0,r0,r7              ;281
00003e  4621              MOV      r1,r4                 ;281
000040  f7fffffe          BL       __aeabi_uidivmod
000044  490c              LDR      r1,|L12.120|
000046  1e40              SUBS     r0,r0,#1              ;283
000048  4288              CMP      r0,r1                 ;283
00004a  d909              BLS      |L12.96|
00004c  00e0              LSLS     r0,r4,#3              ;284
00004e  19c0              ADDS     r0,r0,r7              ;284
000050  4621              MOV      r1,r4                 ;284
000052  f7fffffe          BL       __aeabi_uidivmod
000056  2101              MOVS     r1,#1                 ;284
000058  0900              LSRS     r0,r0,#4              ;284
00005a  07c9              LSLS     r1,r1,#31             ;284
00005c  1e40              SUBS     r0,r0,#1              ;284
00005e  4308              ORRS     r0,r0,r1              ;284
                  |L12.96|
000060  6268              STR      r0,[r5,#0x24]         ;286
                  |L12.98|
000062  9808              LDR      r0,[sp,#0x20]         ;289
000064  4306              ORRS     r6,r6,r0              ;289
000066  980e              LDR      r0,[sp,#0x38]         ;289
000068  4306              ORRS     r6,r6,r0              ;289
00006a  60ae              STR      r6,[r5,#8]            ;289
00006c  b009              ADD      sp,sp,#0x24
00006e  bdf0              POP      {r4-r7,pc}
;;;291    
                          ENDP

                  |L12.112|
                          DCD      ||.constdata||+0x10
                  |L12.116|
                          DCD      0x50000200
                  |L12.120|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;300     */
;;;301    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;302    {
;;;303        uart->TMCTL = (uart->TMCTL & ~UART_TMCTL_TOIC_Msk)| (u32TOC);
000002  0a52              LSRS     r2,r2,#9
000004  0252              LSLS     r2,r2,#9
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;304        uart->IER |= UART_IER_RTO_IE_Msk;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  2210              MOVS     r2,#0x10
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;305    }
000012  4770              BX       lr
;;;306    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;398     */
;;;399    uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;400    {
000002  4604              MOV      r4,r0
;;;401        uint32_t  u32Count, u32delayno;
;;;402    
;;;403        for(u32Count=0; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;404        {
;;;405            u32delayno = 0;
;;;406            while((uart->FSR & UART_FSR_TX_EMPTY_F_Msk) == 0)   /* Wait Tx empty and Time-out manner */
;;;407            {
;;;408                u32delayno++;
;;;409                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L14.38|
                  |L14.12|
00000c  2300              MOVS     r3,#0                 ;405
00000e  e004              B        |L14.26|
                  |L14.16|
000010  1c5b              ADDS     r3,r3,#1              ;406
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L14.26|
;;;410                    return FALSE;
000016  2000              MOVS     r0,#0
;;;411            }
;;;412            uart->THR = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;413        }
;;;414    
;;;415        return u32Count;
;;;416    
;;;417    }
000018  bd70              POP      {r4-r6,pc}
                  |L14.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;406
00001c  05b6              LSLS     r6,r6,#22             ;406
00001e  d5f7              BPL      |L14.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;412
000022  6023              STR      r3,[r4,#0]            ;412
000024  1c40              ADDS     r0,r0,#1              ;412
                  |L14.38|
000026  4290              CMP      r0,r2                 ;403
000028  d1f0              BNE      |L14.12|
00002a  bd70              POP      {r4-r6,pc}
;;;418    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
